[TOC]

# C 语言基础

## C 数据类型

### 整数类型

C 中的基本数据类型分为有符号和无符号两种，使用时一定要注意。

| 类型           | 存储大小    | 值范围                                               |
| :------------- | :---------- | :--------------------------------------------------- |
| char           | 1 字节      | -128 到 127 或 0 到 255                              |
| unsigned char  | 1 字节      | 0 到 255                                             |
| signed char    | 1 字节      | -128 到 127                                          |
| int            | 2 或 4 字节 | -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 |
| unsigned int   | 2 或 4 字节 | 0 到 65,535 或 0 到 4,294,967,295                    |
| short          | 2 字节      | -32,768 到 32,767                                    |
| unsigned short | 2 字节      | 0 到 65,535                                          |
| long           | 4 字节      | -2,147,483,648 到 2,147,483,647                      |
| unsigned long  | 4 字节      | 0 到 4,294,967,295                                   |

---

### 浮点类型

| 类型        | 存储大小 | 值范围                 | 精度      |
| :---------- | :------- | :--------------------- | :-------- |
| float       | 4 字节   | 1.2E-38 到 3.4E+38     | 6 位小数  |
| double      | 8 字节   | 2.3E-308 到 1.7E+308   | 15 位小数 |
| long double | 16 字节  | 3.4E-4932 到 1.1E+4932 | 19 位小数 |

---

### void 类型

void 类型指定没有可用的值。通常用于以下几种情况

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **函数返回为空** C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 **void exit (int status);** |
| 2    | **函数参数为空** C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int rand(void);** |
| 3    | **指针指向 void** 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |

---

## C 中的变量声明

* 类型决定了变量存储的大小和布局
* 变量的名称可以由字母、数字和下划线组成。必须以字母或下划线开头。
* 大小写敏感，区分大小写

| 类型   | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| char   | 通常是一个字节（八位）。这是一个整数类型。                   |
| int    | 对机器而言，整数的最自然的大小。                             |
| float  | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。![img](http://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double | 双精度浮点值。双精度是1位符号，11位指数，52位小数。![img](http://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| void   | 表示类型的缺失。                                             |

变量的声明有两种情况：

1. 一种是`需要建立存储空间`的。例如：int a 在声明的时候已经 `建立了存储空间`
2. 一种是`不需要建立存储空间`的，通过使用 `extern` 关键字声明变量名而不`定义`它。例如：`extern int a` 其中变量 a 可以在别的文件中定义
3. 除非有 `extern` 关键字，否则都是变量的`定义`，而非`声明`

```c
extern int i; // 声明，不是定义，未分配空间
int i; // 声明，也是定义，分配了空间
```

---

## C 常量

常量就是常规的变量，只不过常量的值在定以后不能进行修改。

### 整数常量

整数常量可以是十进制、八进制、十六进制。

> 前缀指定基数：`0x` 或 `0X`表示十六进制，`0` 表示八进制，不带前缀默认表示十进制，整数常量也可以带一个后缀，`U` 和 `L` 的组合，`U` 表示无符号整数 (`unsigned`)，L 表示长整数(`long`)。后缀大小写都可，`U` 和 `L` 顺序任意。

列举几个整数常量实例：

```c
212         /* 合法的，十进制整数 */
215u        /* 合法的，无符号整数 */
30l					 /* 合法的，长整数 */
40ul				 /* 合法的，无符号长整数 */
0xFeeL      /* 合法的，十六进制 */
042					 /* 合法的，八进制 */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */
```

---

### 浮点常量

浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

使用小数形式表示时，必须包含整数部分、小数部分，或者同时包含二者。使用指数形式时，必须包含小数点、指数，或同时包含二者。

带符号的指数是用 `e` 或 `E` 引入的。

```c
3.1415926  /* 合法 */
.1415926   /* 合法 */
1e5					/* 合法 */
1e-5     	 /* 合法 */
1.2e2    	 /* 合法 */
.2e2    	 /* 合法 */
.e2        /* 非法的 */
```

---

### 字符常量

字符常量是括在单引号中，例如，'x' 可以存储在 **char** 类型的简单变量中。

字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）

---

### 字符串常量

字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用空格做分隔符，把一个很长的字符串常量进行分行。

下面的字符串是相等的

```c
"hello, dear"

"hello, \

dear"

"hello, " "d" "ear"
```

---

### 定义常量

C 中定义常量有两种方式

1. 使用 **#define** 预处理器
2. 使用 **const** 关键字

#### 使用 #define 预处理器定义常量：

宏预处理器类似一个「替代」操作符，比如定义了 `#define A 10` 则表示在任何地方使用 `A` 的时候，默认将其替换为了 `10`。

```c
#define identifier value
```

* `#define` 不为宏名分配内存，`const` 也不为常量分配内存。

> 使用宏的时候，注意边界问题
>
> \#define A 10+20 
>
> 则 A / 2 的实际运算为 10 + 20/2，而不是我们理想的 (10+20)/2

#### const 关键字

通常将常量定义为大写字母的形式。

> const type variable = value;

### 两者区别

**(1) 编译器处理方式不同**

- \#define 宏是在预处理阶段展开。
-  const 常量是编译运行阶段使用。

**(2) 类型和安全检查不同**

-  \#define 宏没有类型，不做任何类型检查，仅仅是展开。
-  const 常量有具体的类型，在编译阶段会执行类型检查。

**(3) 存储方式不同**

- \#define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）
- const常量会在内存中分配(可以是堆中也可以是栈中)。

**(4) const 可以节省空间，避免不必要的内存分配。 例如：**

```
#define NUM 3.14159 //常量宏
const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ......
double i = Num; //此时为Pi分配内存，以后不再分配！
double I= NUM; //编译期间进行宏替换，分配内存
double j = Num; //没有内存分配
double J = NUM; //再进行宏替换，又一次分配内存！
```

const 定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 #define 一样给出的是立即数，所以，const 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝。

**(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。**

**(6) 宏替换只作替换，不做计算，不做表达式求解;**

宏预编译时就替换了，程序运行时，并不分配内存。

## C 运算符

* 算术运算符
* 关系运算符
* 逻辑运算符
* [位运算符](#位运算符)
* 赋值运算符
* [杂项运算符](#杂项运算符)

算数运算符、关系运算符、逻辑运算符和赋值运算符同 `java` 中的运算符，不赘述。

### 位运算符

假定 A=60，B=13，则其二进制表示为：

A = 0011 1100

B = 0000 1101

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=0;    ~0=1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| `<<`   | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位`（左边的二进制位丢弃，右边补0）。` | A << 2 将得到 240，即为 1111 0000                            |
| `>>`   | 二进制右移运算符。将一个数的各二进制位全部右移若干位，`正数左补0，负数左补1，右边丢弃`。 | A >> 2 将得到 15，即为 0000 1111                             |

### 杂项运算符

| 运算符     | 描述             | 实例                                 |
| :--------- | :--------------- | :----------------------------------- |
| `sizeof()` | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
| `&`        | 返回变量的地址。 | &a; 将给出变量的实际地址。           |
| `*`        | 指向一个变量。   | *a; 将指向一个变量。                 |
| ? :        | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |

## 分支、循环

C 中的分支（`if else`）、多分支（`switch`）、循环（`for`）与 `java` 类似，不再赘述。要注意，`switch` 中 `case` 表达式后的值，同样只能是整数表达式。

函数

## C 数组

```c
// 这样初始化数组，则数组中所有数据会被初始化为 ‘0’
int arr1[10]={0};

int arr[5] = {1, 2, 3, 4, 5};
int arr1[10]={0};
int len;
GET_ARRAY_LEN(arr1, len)
printf("arr len:%d\n", len);
printf("main sizeof(&arr):%d\n", (int) sizeof(&arr));
printf("array size:%d\n", (int) sizeof(arr));
printf("arr address:%p\n", &arr);
printf("arr:%p\n", arr);
printf("arr[0] address:%p\n", &arr[0]);
printf("*arr:%d\n", *arr);
printf("arr[0]:%d\n", arr[0]);
printf("*(arr + 1):%d\n", *(arr + 1));
printf("(arr + 1) 的地址:%p\n", arr + 1);
```

运行结果

![](https://ws1.sinaimg.cn/large/006tNc79ly1g2jn4abys0j30u80iejry.jpg)

> * 数组作为函数参数的时候，会被转换为指针类型。
> * 数组是一个常量指针
> * 数组名是一个指向数组中第一个元素的`常量型指针`，`arr 代表整个数组的首地址，也就是 arr[0] 的地址->（&arr[0]）`
> * sizeof(arr) 得到整个数组 arr 的大小，sizeof(arr[0]) 得到单个元素的大小
> * arr + 1 表示直接对数组地址操作
> * 可以通过 `*(arr + 1)、*(arr +2)`访问数组元素。等价于 arr[1]，+1 代表指针下移一位，指向 `arr[1]`
> * char a[]="abc";  // 末尾自动加 '\0' 数组长度比下边声明方式大
>
> char a[] = {'a','b','c'}
>
> * 局部变量定义的数组必须要初始化（给定初始数组大小）
>
>   * 数组的元素 arr[0] 表示的是变量，如果需要取地址，需要加 `&` 符号 `&arr[0]`
>
> * *arr = 10，等价于 arr[0] = 10。\*arr 可以得到或者修改数组首个元素的值
>
> * 两个数组，执行 arr = arr1 会报错。数组变量之间不能被相互赋值，因为数组实际上是 `const` 的指针，所以不能被赋值。int b[] <==> const int *b。int *q = b; 这样是可以的。
>
> * 将数组传递给函数有三种写法：
>
>   * int fun(int *a)  定义成指针
>
>   * int fun(int a[])  不指定大小
>    * int fun(int a[10])  指定大小
>
> * 二维数组作为函数参数，可以不写行数，不可以省略列数
>
>   > void test(int a\[][3]);
>   
> * int arr[2]={1,2};  printf("&arr+1:%p\n", &arr+1);   // 在最后一个元素的地址上+1

### 获取数组长度

> **利用宏来计算数组 size，只在 main 函数中有作用，因为数组作为函数参数的时候，会被转换为指针类型**
>
> \#define GET_ARRAY_LEN(array, len){len = (sizeof(array) / sizeof(array[0]));}

### 多维数组

最简单的多位数组就是`二维数组`，二维数组在逻辑上是`方阵`，但是在物理上是`按行来存放的，内存是连续的`。

```c
// 二维数组定义，不满的位置，0 补位
int a[2][3] = {1, 2, 3, 4, 5}; // 等价于下面的写法
int a1[2][3] = {{1, 2, 3},{4, 5}};  
```

> 假设数组int arr 有 4 列
>
> `二维数组步长是一行的长度`，比如如下的例子：
>
> ```c
> arr + 1 address is 00EFFC04
> arr + 2 address is 00EFFC14
> ```
>
> 因为一行有四个元素，元素是 `int` 类型，`int` 类型一个元素占 4 个字节，则一行有 16 个字节，所以数组再+1 后地址增加了 16 个字节。
>
> `具体到某一个数组元素的步长，是元素本身大小`，如：
>
> ```c
> arr[0][0] + 0  address is 00EFFC14
> arr[0][0] + 1  address is 00EFFC18
> ```

## C enum（枚举）

语法：

> enum 枚举名 {枚举元素 1,枚举元素 2,…};

枚举有如下几种定义方法

```c
// 1.声明
enum DAY {
    MON, TUE, WEN = 4
};

// 2.声明同时定义
enum DAY1 {
    MON1, TUE1, WEN1 = 4
} day1;

// 3.声明同时定义，省略枚举类型名
enum {
    MON2, TUE2, WEN2 = 4
} day2;
```

> * 第一个枚举元素默认值为整型的 0，后续枚举成员的值在前一项基础上 +1；
>
> * 枚举类型的值被当成是 int 或 unsigned int 类处理，理论上不能对其进行遍历，某些特殊情况下可以，比如枚举变量的值是连续的时候：
>
> ```c
> int main(){
>   enum DAY{
>      MON,TUE,WEN,THU
>   };  
>   // enum DAY day; 声明枚举
>   for(int i = MON; i < THU; i++){
>    	printf("%d ",i); 
>   }
>   return 0;
> }
> // 运行结果：0 1 2 3
> ```
>
> * 枚举类型可以手动指定改变其中某个成员的值
>
> ```c
> enum COLOR{
>   RED,YELLOW,BLUE = 4,GRAY
> };
> // 这些值为：0 1 4 5
> ```
>

### 将整数转换为枚举

```c
int a = 1;
day = (enum DAY) a;
// day = a; 错误写法
```

## 字符数组与字符串

C 语言中，字符串实际上是使用 **null** 字符 `'\0'` 终止的一维数组。**因此，一个以 null 结尾的字符串，包含了组成字符串的字符**。

字符数组，是一个数组，存储的元素是`字符`。

一些字符串相关的函数在 `string.h` 中查找，如 `strlen、strcpy、strcat、strcmp` 等等。

C/C++ 中定义的字符串的内存表示

![](https://ws2.sinaimg.cn/large/006tNc79ly1g2qfvwkhnej30fk05b3ym.jpg)

两种声明方式

```c
// 1.挨个定义组成字符串的字符
char [6] = {'h','e','l','l','o'};
// 2.此种方式定义会默认在字符串结尾添加 '\0'，所以要注意该字符串长度不是 5
char [] = "hello";
```

### strlen 与 sizeof 区别

> strlen 是函数，sizeof 是运算符，二者得到的结果类型都是 size_t，即 unsigned int 类型
>
> sizeof 计算的是**「变量的大小」**，不受字符 `’\0‘`影响
>
> strlen 计算的是 **「字符串的长度」**，以`‘\0’` 作为长度判定依据，即，从开始，到遇到的第一个 `'\0'`
>
> 也就是
>
> ```c
> char c[] = "hello";
> sizeof(c);  // 结果为 6
> strlen(c);  // 结果为 5
> ```

### 指向字符串的指针与字符数组

```c
char *p = "abc";
char c[] = "abc";
```

"abc" 存储在静态常量区。p 是栈区的一个指针，指向位于静态常量区的字符串；c 也位于静态常量区，但是用一个字符串常量来初始化一个栈区的字符数组，`会在栈区开辟一段空间，然后将字符串常量拷贝到栈区，这时候它存储的只是字符串常量的一个副本，更改 array 数组，并不能更改字符串常量`。

> p 指向的是一个常量区的字符串，该字符串是不允许被更改的，是只读的、为了防止通过指针 p 来修改产概念股，通常将 p 声明为 const char*。

## 指针

指针是一个`变量`，存储的是另一个变量的地址，即内存位置的直接地址。使用前需要声明。

> 所有指针的值的时机数据类型，不管是整型、浮点型、字符型，还是其他类型，都是一样的。都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一不同的是，指针所指向的变量或常量的数据类型不同。

### C 中的 NULL 指针

`在声明指针变量的时候，如果没有确切的地址可以赋值，为指针变量赋值一个 NULL 值是一个好的变成习惯`。赋值为 NULL 值的指针被称为`空指针`。NULL 指针是一个定义在标准库中的值为零的常量。

```c
int main(){
 	int *ptr = NULL;
  printf("ptr 的地址为：%p\n",ptr);
  return 0;
}
// ptr 的地址为：0x0
```

在大多数的操作系统上，`程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的`。内存地址 0 有特殊意义，表明指针不指向一个可访问的内存为止，不指向任何东西。

```c
int *ptr = NULL;
if(ptr){...}  // 如果 ptr 不为空，则执行 if 中的。。。
if(!ptr){...} // 如果 ptr 为空，则执行 if 中的。。。  
```

> 对指针取非，!ptr <==> (ptr == 0)

### 指针数组

> int *p[3];  // 指针数组，其中存储的元素都是指针，此数组存储指向 int 类型的指针

```c
#include <stdio.h>
 
const int MAX = 3;
 
int main ()
{
   int  var[] = {10, 100, 200};
   int i, *ptr[MAX];
 
   for ( i = 0; i < MAX; i++)
   {
      ptr[i] = &var[i]; /* 赋值为整数的地址 */
   }
   for ( i = 0; i < MAX; i++)
   {
      printf("Value of var[%d] = %d\n", i, *ptr[i] );
   }
   return 0;
}
```

> 结果：
> 
> Value of var[0] = 10
> Value of var[1] = 100
> Value of var[2] = 200

### 指向指针的指针

指向指针的指针是一种`多级间接寻址`的形式，或者说是一个`指针链`。通常，一个指针包含的是一个变量的地址，当我们定义一个指向指针的指针时，此指针包含前一个指针的地址，前一个指针指向包含实际值的位置。

![C ä¸­æåæéçæé](https://ws1.sinaimg.cn/large/006tNc79ly1g2tp21rpumj30bi01tweb.jpg)

指向指针的指针如下声明：

> int **var;
>
> // 对指向指针的指针`解引用`时，需要两个星号
>
> ```c
> int main(){
>   int i = 1;
>   int *var;
>   int **pInt;
>   var = &i;
>   pInt = &var;
>   printf("var value:%d\n",i);
> 	printf("*var value:%d\n",*var);
>   printf("**pInt value:%d\n",**pInt);
>   return 0;
> }
>          
> // 结果
> // var value:1
> // *var value:1
> // **pInt value:1
> ```

### 传递指针给函数

```c
void modifySomething(int *pInt) {
    *pInt = 5;
}

int main(){
 	int a = 1;
 	modifySomething(&a);
  printf("after invoke modifySomething a = %d\n", a);
  return 0;
}
// after invoke modifySomething a = 5
```

> 指针作为参数时，还可以接受对应类型的数组作为参数。
>

```c
int getAverage(int *arr,int size);
int main(){
  int arr[]={1,2,3,4,5};
  printf("Average of arr is :%d\n", getAverage(arr, sizeof(arr) / sizeof(int)));
  return 0;
}

int getAverage(int *arr, int size) {
    int sum = 0;
    for (size_t i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}

// Average of arr is :3
```

### 从函数返回指针

```c
int * fun(){
  static int r[10];
	...
    return r;
}
```

> C 语言不支持在调用函数式返回局部变量的地址，除非定义局部变量为 static。
>
> 因为局部变量存储在栈区，当函数调用结束，会被释放掉，函数内的变量也就不再拥有那个内存地址，所以不能返回其指针。

### 指针实例说明

```c
int **ptr;  // 指向 int 类型指针的指针
int *risks[10]; // 具有十个元素的数组，每个元素是一个指向 int 类型的指针
int (*risks)[10]; // 一个指针，指向具有 10 个元素的 int 数组
int *arr[3][4]; // 具有 3x4 个元素的数组，每个元素是一个指向 int 类型的指针
int (*arr)[3][4]; // 一个指针，指向具有 3x4 个元素的 int 二维数组
int (*arr[3])[4];  // 一个具有三个元素的数组，每个元素是一个指向具有 4 个元素的 int 数组的指针
```

### 函数指针

```c
// 定义一个函数指针
int func(int,int);
int (*p)(int,int);  // 指向一个具有两个 int 类型参数的函数
p=&func;
```

### 关于指针，几点注意的

> * 指针存的是内存地址，操作系统进行资源调度时，会根据这些变量存的地址去请求和使用那个地址代表的内存区域。
> * **初始化指针不赋值 NULL。**这样的指针会指向一片位置区域，这样的指针不是空指针，但是指向一片访问受限的内存区域，无法被使用，被称为`野指针`，而且难以调试。
> * **free() 后指针要赋 NULL。**使用 free() 释放内存后，指针依旧存放着那片内存地址，容易有奇怪的 bug。称为`悬空指针`。

## 结构体

### 声明/定义结构体

```c
// 1.声明
struct Books {
 	char name[50];
  char author[50];
  int age;
};

// 2.声明且定义一个结构体变量 「books」
struct Books {
 	char name[50];
  char author[50];
  int age; 
} books;
// 3.声明同时初始化一个结构体变量
struct {
 	char name[50];
  char author[50];
  int age; 
} books = {"Java","John",300};
// 4.使用 typedef 声明一个结构体，以后再使用的时候，可以不需要 struct struct_name variable_name 这种形式，可以直接 Books b; 这种形式使用
typedef struct {
 	char name[50];
  char author[50];
  int age; 
} Books;
```

### 指向结构的指针

```c
struct Books book,*struct_book;
struct_book = &book;
```

为了使用指向该结构的指针访问结构的成员，必须使用 `->` 运算符。

```c
// 访问 Books 中的 name 属性
struct_book->name
```

### 结构体中成员的存储空间分配（字节对齐）

> 结构体中的成员变量的空间分配，是按照成员变量中所占空间最大的基本数据类型大小来作为分配单元的。而且，`成员变量的存储空间不能跨分配单元`，如果当前空间所剩大小不足以为下一个成员变量分配，则会存储到下一个存储单元中。

```c
typedef struct {
   char name;
   int age;
   char sex;
} Person;

typedef struct {
 	char name;
  char sex;
  int age;
} Person1;

typedef struct {
  char name[5];
  char sex;
  int age;
} Person2;

Person p;
Person1 p1;
Person2 p2;

// 假设系统为 64 位系统，此种情况下，sizeof(p) = 12;
// sizeof(p1) = 8;
// 分析如下：p，char 占 1 字节，int 占 4 字节，所以以 4 字节作为存储单元大小分配空间，则：(一个单元)(name(1byte)+单元中空闲(3byte)) + (一个单元)age(4byte) + (一个单元)(sex(1byte)+空闲(3byte))  一共三个单元
// p1：(一个单元)(name(1byte) + sex(1byte) + 空闲(2byte)) + (一个单元)age(4byte)  一共两个单元
// p2:(name(4byte) + name(1byte) + 空闲(3byte)) + (sex(1byte) + 空闲(3byte)) + age(4byte) = 16byte
```

> 1. 结构体变量的首地址能够被其最宽基本类型成员的大小所整除。
>
> 2. 结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)。即结构体成员的末地址减去结构体首地址(第一个结构体成员的首地址)得到的偏移量都要是对应成员大小的整数倍。
>
> 3. 结构体的总大小为结构体最宽`基本类型`成员大小的整数倍，如有需要编译器会在`成员末尾加上填充字节`。

## 共用体

共用体是一种特殊的数据类型，组成结构类似结构体，但是它允许你在`相同的内存位置存储不同的数据类型`。你可以定义一个带有多个成员的共用体。共用体提供了一种使用相同的内存位置的方式。

> 共用体中任何时候只能有一个成员带有值，否则容易对值造成损坏。

```c
union [union tag]{
 	member definition;
  member definition;
  ...
}var1,var2...;
```

一个变量（相同的内存位置）可以存储`多个多种`类型的数据。

`共用体的内存大小，是成员变量中占用空间最大的成员所占的空间`。

```c
typedef union {
  	int i;
  	float f;
  	char c[20];
}Data;
int main (){
  	Data data;
 		printf("size of Data:%d\n",(int)sizeof(data));
  	return 0;
}
// 结果是 20，因为 char 数组最大，占了 20 字节
```

### 共用体用法

```c
int main(){		
Data d;
    printf("data size:%d\n", sizeof(d));
    d.i = 10;
    printf("data i:%d\n", d.i);
    d.f = 20;
    printf("data i:%f\n", d.f);
    strcpy(d.str, "hello");
    printf("data i:%s\n", d.str);

    d.i = 20;
    d.f = 10;
    strcpy(d.str, "world");
    printf("i=%d,f=%f,str=%s\n", d.i, d.f, d.str);
  	return 
}
```

输出结果

![pic](https://ws4.sinaimg.cn/large/006tNc79ly1g2sqkv68xwj31bk080t8u.jpg)

后边的赋值方式，因为最后把内存空间给字符串使用了，导致前边的两个数据有锁所坏，`可见共用体同一时间只能使用一个变量`。

## 函数

根据函数的使用范围，能否被其他源文件引用，将函数分为`内部函数`和`外部函数`。

### 内部函数

内部函数又称静态函数。使用内部函数，可以使函数作用于只局限于所在文件。`即使在不同的文件中有同名的内部函数，也互不干扰。`

全局变量加上 `static` 修饰，则该变量对其他文件不可见，作用域只限定在所在文件。

`static` 修饰的变量，存储于进程的全局数据区。`即，若用 `static` 修饰的局部变量，在函数返回时，她的值也会保持不变。`

声明内部函数

> static 类型名 函数名（形参表）
>
> static int max(int a, int b)

### 外部函数

如果在定义函数的时候，在函数的最左端加 `extern` 关键字，则此函数是外部函数，可供其他文件调用。C 语言规定，声明函数时，省略 `extern` 关键字，默认为外部函数。

> extern int max(int a, int b)

注意：

在需要调用外部函数的其他文件中，需要在文件开头对此函数做声明（在本文件中调用一个函数，也要用函数原型来声明）。在对此函数做声明时，要加关键字 `extern`，表示该函数是在其他文件中定义的外部函数。

C 语言规定，声明函数时，可以省略形参名字，所以声明一个外部函数可以简写为：

> int max(int,int)

这就是`函数原型`。所以函数原型的作用可以理解为：`用函数原型，把函数的作用域扩展到定义该函数的文件之外`（不必使用 extern）。只要在使用该函数的每一个文件中包含该函数的原型即可。函数原型通知编译系统：`该函数在本文件中稍后定义，或在另一文件中定义`。

利用函数原型扩展函数作用域的例子最常见的就是使用 `#include` 预处理指令。在 `#include` 命令所指定的头文件中，包含有调用函数时所需的信息。例如，在程序中需要调用sin函数，但三角函数并不是由用户在本文件中定义的，而是存放在数学函数库中的。按以上的介绍，必须在本文件中写出sin函数的原型，否则无法调用sin函数。sin函数的原型是：
    double sin(double x);
`本来应该由程序设计者在调用库函数时先从手册中查出所用的库函数的原型，并在程序中一一写出来`，但这显然是麻烦而困难的。为减少程序设计者的困难，在头文件cmath中包括了所有数学函数的原型和其他有关信息，用户只需用以下#include命令：
   ` #include <cmath>`
即可。这时，在该文件中就能合法地调用各数学库函数了。

### 函数指针

### 回调函数

### 从函数返回数组

C 不允许返回一个完整数组作为函数参数，`可以通过指定不带索引的数组名（返回数组指针）来返回一个指向数组的指针。`

```c
int main(){
 int *p = testArray();
    for (size_t i = 0; i < 10; i++) {
      // 通过位移操作指针来获取数组中内容
        printf("*(p + %d) : %d\n", (int) i, *(p + i));
    }
  return 0;
}

int *testArray() {
    static int a[10]; // 此处若要返回数组地址，则必须定义数组为 static 类型的，因为其是局部变量
    srand((unsigned int) time(NULL));
    for (size_t i = 0; i < 10; i++) {
        a[i] = rand();
        printf("a[%d] = %d\n", (int) i, a[i]);
    }
    return a;
}
```

> C 中不支持在函数外返回`局部变量`地址，除非定义局部变量为 static

### 函数指针作为某个函数的参数

`函数指针变量可以作为某个函数的参数来使用`，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

```c
void int getRadom();
void array(int *array, size_t size, int (*pInt)(void))
int main(){
  int array[10];
  array(array,10,getRandom);
  for(int i = 0; i < 10; i++){
   	printf("%d\n",array[i]); 
  }
  return 0;
}

int array(int *array,size_t size,int (*pInt)(void)){
 	for(size_t i = 0; i < size; i++;){
  	array[i] = pInt();
  }
}
void int getRandom(){
 	return rand(); 
}
```

## C 预处理器

C 预处理器可以简单理解为`「文本替换工具」`。它会将调用宏的位置，替换为宏定义的内容。它们会指示编译器在实际编译之前完成所需的预处理。简写为`CPP（C Preprocessor）`。

下面列出一些重要的预处理器

| 指令     | 描述                                                        |
| :------- | :---------------------------------------------------------- |
| #define  | 定义宏                                                      |
| #include | 包含一个源代码文件                                          |
| #undef   | 取消已定义的宏                                              |
| #ifdef   | 如果宏已经定义，则返回真                                    |
| #ifndef  | 如果宏没有定义，则返回真                                    |
| #if      | 如果给定条件为真，则`编译`下面代码。`注意，不是执行`        |
| #else    | #if 的替代方案                                              |
| #elif    | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |
| #endif   | 结束一个 #if……#else 条件编译块                              |
| #error   | 当遇到标准错误时，输出错误消息                              |
| #pragma  | 使用标准化方法，向编译器发布特殊的命令到编译器中            |

### 预处理器实例

```c
#define MESSAGE 10
```

上面这段代码定义了宏 MESSAGE，代码中使用此宏时，会将所有的 `MESSAGE`替换为 10。

```c
#include "myheader.h" // 从本地目录中获取 myheader.h，找不到才去系统库中寻找
#include <stdio.h>  // 直接从系统库中获取 stdio.h
```

### 预定义宏

ANSI C 定义了许多宏，编程中可以直接使用，但是不能直接修改这些预定义的宏。

| 宏       | 描述                                                |
| :------- | :-------------------------------------------------- |
| __DATE__ | 当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 |
| __TIME__ | 当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。    |
| __FILE__ | 这会包含当前文件名，一个字符串常量。                |
| __LINE__ | 这会包含当前行号，一个十进制常量。                  |
| __STDC__ | 当编译器以 ANSI 标准编译时，则定义为 1。            |

```c
#include <stdio.h>
int main()
{
   printf("File :%s\n", __FILE__ );
   printf("Date :%s\n", __DATE__ );
   printf("Time :%s\n", __TIME__ );
   printf("Line :%d\n", __LINE__ );
   printf("ANSI :%d\n", __STDC__ );
	 return 0;
}
```

```
// 结果
File :test.c
Date :Jun 2 2012
Time :03:36:24
Line :8
ANSI :1
```

### 预处理器运算符

#### 宏延续运算符(`\`)

一个宏通常写在一个单行上。换行会报错。可以使用宏延续运算符(`\`)来为宏换行

```c
#define func(a,b) \
	printf(#a "and" #b ":Hello World!\n");
```

#### 字符串常量化运算符（`#`）

在宏中，当需要把一个宏的参数转换为字符串常量的时候，使用字符串常量化运算符（#）。

```c
#include <stdio.h>
#define MESSAGE(a,b) \
					printf(#a " and " #b)

int main(){
 	MESSAGE(lx,sy); 
  return 0;
}

// 结果：
// lx and sy
```

#### 标记粘贴运算符(`##`)

`##` 会合并两个参数，它允许在宏定义中将两个独立的标记合并为一个标记。

```c
#define joint(a) printf("token" #a "=%d\n",token##a)

int main(){
 	int token1 = 1;
  joint(1);
  return 0;
}
// 输出：
// token1=1
```

#### define() 运算符

用在常量表达式中，用来确定一个标识符是否已经使用 #define 定义过。，已定义，为 true（非 0），否则为 false。

```c
#if !define(MESSAGE)
#define MESSAGE "hello world!"
#endif
// 等价于下面写法
#ifndef MESSAGE
#define MESSAGE "hello world!"
#endif
```

### 参数化的宏

CPP 可以使用参数化的宏模拟函数

```c
// 宏参数在使用的时候一定要加（），因为宏只是简单地替换文本，不加（）易出错
#define MAX(a,b) ((a)>(b)?(a):(b))
int main(){
 	printf("compare 1,2,max = %d", MAX(1, 2));
  return 0;
}
```

## C 标准库-<stdio.h>

### printf()

C 库函数 **int printf(const char *format,…)**发送格式化输出到标准输出 `stdout`

printf() 函数的调用格式为：

> printf("<格式化字符串>",<参量表>);
>
> printf 函数声明：
>
> `int printf(const char *format,…)`

#### 参数

* format — 这是字符串，`包含了要被写入到标准输出 stdout 的文本`。`还可以包含嵌入的 format 标签`，format 标签可被随后的附加参数中的指定值替换，并按照需求进行格式化。format 标签的属性是 `%[flags][width][.precision][length]specifier`

| 格式字符 | 意义                                       |
| :------- | :----------------------------------------- |
| d        | 以十进制形式输出带符号整数(正数不输出符号) |
| o        | 以八进制形式输出无符号整数(不输出前缀0)    |
| x,X      | 以十六进制形式输出无符号整数(不输出前缀Ox) |
| u        | 以十进制形式输出无符号整数                 |
| f        | 以小数形式输出单、双精度实数               |
| e,E      | 以指数形式输出单、双精度实数               |
| g,G      | 以%f或%e中较短的输出宽度输出单、双精度实数 |
| c        | 输出单个字符                               |
| s        | 输出字符串                                 |
| p        | 输出指针地址                               |
| lu       | 32位无符号整数                             |
| llu      | 64位无符号整数                             |

| flags（标识） | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| -             | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 |
| +             | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 |
| 空格          | 如果没有写入任何符号，则在该值前面插入一个空格。             |
| #             | 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 |
| 0             | 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 |

| width（宽度） | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| (number)      | 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 |
| *             | 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |

| .precision（精度） | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| .number            | 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 |
| .*                 | 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |

| length（长度） | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| h              | 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 |
| l              | 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 |
| L              | 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 |

* 附加参数—根据不同的 format 字符串，函数需要一系列的附加参数，`每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 %\ 标签。参数的个数应与 % 标签个数相同。`

#### 返回值

成功，返回写入的字符总数，失败返回一个负数。

#### 实例

```c
int main(){
	inputOutput();
  return 0;
}
/**
 * 输入输出
 */
void inputOutput() {
    const char *s = "hello";
    printf("output exercise\r\n");
    int num = printf("%4d\n", 10);  // 要求有 4 位，右对齐
    printf("%.4d\n", 10);  // 要求有 4 位，不足左边补零
    printf("%-4d\n", 10);  // 要求有 4 位，左对齐
    printf("%*s\n", 10, s);  //精度在 format 字符串中未指定，但是作为附加参数值，放在要被格式化的参数之前，也就是此例中的 s 前。
    printf("Hexadecimal:%x %x %X %#x\n", 5, 10, 10, 6);
    printf("num=%d", num);
}
```

#### OutPut

```
output exercise
  10
0010
10  
     hello
Hexadecimal:5 a A 0x6
num=5
Process finished with exit code 0
```



## 杂项

### size_t

#### 使用

一个基本的[无符号整数](https://baike.baidu.com/item/无符号整数)的C / C + +类型， 它是sizeof操作符返回的结果类型， 该类型的大小可选择。因此，它可以存储在理论上是可能的任何类型的[数组](https://baike.baidu.com/item/数组)的最大大小。 换句话说，一个[指针](https://baike.baidu.com/item/指针)可以被安全地放进为size_t类型（一个例外是类的[函数指针](https://baike.baidu.com/item/函数指针)，但是这是一个特殊的情况下）。 size_t类型通常用于循环、数组索引、大小的存储和地址运算。 虽然size_t可以存储一个指针，它的目的是更好地使用另一个unsinged整数类型uintptr_t形式。 在某些情况下，使用size_t类型是更为有效，比习惯性使用无符号类型的程序会更安全。

size_t是在基于[无符号整数](https://baike.baidu.com/item/无符号整数)memsize类型的C / C + +的标准库中定义的。 C语言中，此类型位于头文件[stddef.h](https://baike.baidu.com/item/stddef.h)中，而在C++中，则位于cstddef中。

#### 详细解释

`size_t` 是一种“整型”类型，里面保存的是一个**整数**，像 `int、long` 一样。这种整数用来记录一个大小（size）。size_t 的全称应该是 `size type`，就是说“一种用来记录大小的数据类型”。

通常我们用 `sizeof()` 操作的时候，这个函数返回值为 `size_t` 类型。

> [size_t][]（来自百度百科）
>
> size_t类型的数据其实是保存了一个整数，所以它也可以做加减乘除，也可以转化为int并赋值给int类型的变量。
>
> 类似的还有wchar_t, ptrdiff_t。
>
> wchar_t就是wide char type，“一种用来记录一个宽字符的数据类型”。
>
> ptrdiff_t就是pointer difference type，“一种用来记录两个指针之间的距离的数据类型”。
>
> 通常，size_t和ptrdiff_t都是用typedef来实现的。你可能在某个头文件里面找到类似的语句：
>
> typedef unsigned int size_t;
>
> 而wchar_t则稍有不同。在一些旧的编译器中，wchar_t也可能是用typedef来实现，但是新的标准中wchar_t已经是C/C++语言的关键字，wchar_t类型的地位已经和char, int的地位等同了。
>
> 在标准C/C++的语法中，只有int float char bool等基本的数据类型，至于size_t,或size_type都是以后的编程人员为了方便记忆所定义的一些便于理解的由基本数据类型的变体类型。
>
> 例如：typedef int size_t;定义了size_t为整型。

## 问题

[遇到的问题](./question)

## Small Knowledge

* 指针类型变量在 32 位系统中占 4 字节，在 64 位系统中占 8 字节

* 数组作为参数是，被编译器解释为指针类型，所以其所占内存为指针所占内存大小。

* // strdup:POSIX 标准中的名字；

  // \_strdup:ISO C++ 标准中的名字，且这些ISO标准的函数有许多安全版本，如：_cprintf_s；

参考网站
--

 [C 语言教程](http://www.runoob.com/cprogramming/c-tutorial.html)

[size_t]: https://baike.baidu.com/item/size_t

[if、#if、#ifdef、#if defined 区别](https://blog.csdn.net/freeWayWalker/article/details/50035923)

[浅析C语言之uint8_t / uint16_t / uint32_t /uint64_t](https://blog.csdn.net/Mary19920410/article/details/71518130)

